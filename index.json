[{"content":"Prophet 简介 Prophet 是由 Facebook（现为 Meta）开发的开源时间序列预测工具，旨在为具有趋势和季节性成分的时间序列数据提供高准确性、易解释的预测模型。它基于可加性模型，将时间序列分解为趋势、季节性、节假日效应和残差，为用户提供灵活且强大的预测能力。\n主要特点 易于使用\n快速上手：少量代码即可完成建模和预测。 友好的 API：简单直观的接口，适合数据科学家和业务分析师。 处理复杂的时间序列\n趋势分解：自动检测并建模数据的增长或减少趋势。 季节性调整：支持每日、每周、每年的季节性因素。 节假日效应：纳入节假日和特殊事件的影响。 鲁棒性强\n应对异常值：对缺失值和异常值有良好的容错性。 缺失数据处理：无需对缺失数据进行复杂的插值。 可解释性\n组件分解：单独查看趋势、季节性和节假日效应的影响。 透明的模型参数：便于理解和调整模型。 灵活性\n自定义季节性：允许添加自定义的季节性周期。 支持先验知识：可通过参数调整引入领域知识。 基本原理 Prophet 使用可加性模型，将时间序列表示为多个组件的和：\n$$ y(t) = g(t) + s(t) + h(t) + \\varepsilon_t $$\n其中：\ng(t) ：趋势函数，表示非周期性变化。 s(t) ：季节性函数，表示周期性变化（如年度、每周、每日）。 h(t) ：节假日效应，捕捉特定日期的影响。 ɛ_t ： 误差项，表示未解释的部分。 安装方法 Python 版本安装\npip install prophet 注意：早期版本的包名为 fbprophet，从 v1.0 版本开始更名为 prophet。\nR 版本安装\ninstall.packages(\u0026#39;prophet\u0026#39;) 基本使用步骤 导入库\nfrom prophet import Prophet import pandas as pd 准备数据\n数据需要是一个包含两列的 DataFrame：\nds：日期列，格式为 %Y-%m-%d 或日期时间格式。 y：数值列，表示对应日期的观察值。 df = pd.read_csv(\u0026#39;your_time_series.csv\u0026#39;) df[\u0026#39;ds\u0026#39;] = pd.to_datetime(df[\u0026#39;date_column\u0026#39;]) df[\u0026#39;y\u0026#39;] = df[\u0026#39;value_column\u0026#39;] 创建并拟合模型\nmodel = Prophet() model.fit(df) 进行预测\n创建未来日期的 DataFrame\nfuture = model.make_future_dataframe(periods=365) # periods 参数指定预测的天数 预测未来\nforecast = model.predict(future) 可视化结果\n绘制预测图\nmodel.plot(forecast) 绘制组件图\nmodel.plot_components(forecast) 高级功能 添加自定义季节性\n如果数据中存在特定的季节性，可以自定义添加，例如每周季节性：\nmodel = Prophet(weekly_seasonality=False) model.add_seasonality(name=\u0026#39;weekly\u0026#39;, period=7, fourier_order=3) 纳入节假日效应\nfrom prophet.translate import hdays holidays = hdays(\u0026#39;CN\u0026#39;) # 获取中国的法定节假日 model = Prophet(holidays=holidays) 调整模型参数\n变化点灵活性：控制趋势变化点的灵活性\nmodel = Prophet(changepoint_prior_scale=0.05) 季节性模式：使用乘法季节性\nmodel = Prophet(seasonality_mode=\u0026#39;multiplicative\u0026#39;) 处理异常值\n对异常点进行标记并设置权重：\ndf[\u0026#39;cap\u0026#39;] = 某个上限值 df[\u0026#39;floor\u0026#39;] = 某个下限值 model = Prophet(growth=\u0026#39;logistic\u0026#39;) 模型评估与优化 交叉验证\n使用交叉验证评估模型性能：\nfrom prophet.diagnostics import cross_validation df_cv = cross_validation(model, initial=\u0026#39;730 days\u0026#39;, period=\u0026#39;180 days\u0026#39;, horizon=\u0026#39;365 days\u0026#39;) 性能指标\n计算预测性能指标：\nfrom prophet.diagnostics import performance_metrics df_p = performance_metrics(df_cv) 优势与局限性 优势\n简洁易用：适合没有时间序列背景的用户。 高度自动化：默认参数通常能给出不错的结果。 可扩展性：便于添加自定义组件。 局限性\n对突发性变化敏感：可能无法很好地预测突然的趋势变化。 有限的模型类型：主要基于可加性模型，可能不适用于非加性的复杂模式。 应用场景 业务指标预测：如销售额、用户增长量等。 资源规划：服务器负载、流量监控等。 金融时间序列：股票价格、交易量预测等。 总结 Prophet 是一款强大且易于使用的时间序列预测工具，特别适合处理具有明显趋势和季节性的业务数据。通过灵活的模型配置和友好的接口，用户可以快速构建并部署预测模型，提高业务决策的科学性和准确性。\n","permalink":"https://Rookie-AI.github.io/blog/%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E5%88%86%E6%9E%90prophet/","summary":"\u003ch3 id=\"prophet-简介\"\u003eProphet 简介\u003c/h3\u003e\n\u003cp\u003eProphet 是由 Facebook（现为 Meta）开发的开源时间序列预测工具，旨在为具有趋势和季节性成分的时间序列数据提供高准确性、易解释的预测模型。它基于可加性模型，将时间序列分解为趋势、季节性、节假日效应和残差，为用户提供灵活且强大的预测能力。\u003c/p\u003e\n\u003chr\u003e\n\u003ch3 id=\"主要特点\"\u003e主要特点\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e易于使用\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e快速上手\u003c/strong\u003e：少量代码即可完成建模和预测。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e友好的 API\u003c/strong\u003e：简单直观的接口，适合数据科学家和业务分析师。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e处理复杂的时间序列\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e趋势分解\u003c/strong\u003e：自动检测并建模数据的增长或减少趋势。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e季节性调整\u003c/strong\u003e：支持每日、每周、每年的季节性因素。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e节假日效应\u003c/strong\u003e：纳入节假日和特殊事件的影响。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e鲁棒性强\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e应对异常值\u003c/strong\u003e：对缺失值和异常值有良好的容错性。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e缺失数据处理\u003c/strong\u003e：无需对缺失数据进行复杂的插值。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e可解释性\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e组件分解\u003c/strong\u003e：单独查看趋势、季节性和节假日效应的影响。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e透明的模型参数\u003c/strong\u003e：便于理解和调整模型。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e灵活性\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e自定义季节性\u003c/strong\u003e：允许添加自定义的季节性周期。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e支持先验知识\u003c/strong\u003e：可通过参数调整引入领域知识。\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3 id=\"基本原理\"\u003e基本原理\u003c/h3\u003e\n\u003cp\u003eProphet 使用可加性模型，将时间序列表示为多个组件的和：\u003c/p\u003e\n\u003cp\u003e$$\ny(t) = g(t) + s(t) + h(t) + \\varepsilon_t\n$$\u003c/p\u003e\n\u003cp\u003e其中：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eg(t) ：趋势函数，表示非周期性变化。\u003c/li\u003e\n\u003cli\u003es(t) ：季节性函数，表示周期性变化（如年度、每周、每日）。\u003c/li\u003e\n\u003cli\u003eh(t) ：节假日效应，捕捉特定日期的影响。\u003c/li\u003e\n\u003cli\u003eɛ_t  ： 误差项，表示未解释的部分。\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3 id=\"安装方法\"\u003e安装方法\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003ePython 版本安装\u003c/strong\u003e\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003epip install prophet\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cblockquote\u003e\n\u003cp\u003e注意：早期版本的包名为 \u003ccode\u003efbprophet\u003c/code\u003e，从 v1.0 版本开始更名为 \u003ccode\u003eprophet\u003c/code\u003e。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003cstrong\u003eR 版本安装\u003c/strong\u003e\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003einstall.packages\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;prophet\u0026#39;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003chr\u003e\n\u003ch3 id=\"基本使用步骤\"\u003e基本使用步骤\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e导入库\u003c/strong\u003e\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003efrom\u003c/span\u003e prophet \u003cspan style=\"color:#f92672\"\u003eimport\u003c/span\u003e Prophet\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003eimport\u003c/span\u003e pandas \u003cspan style=\"color:#66d9ef\"\u003eas\u003c/span\u003e pd\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\u003cstrong\u003e准备数据\u003c/strong\u003e\u003c/p\u003e","title":"时间序列分析: Prophet"},{"content":"关于我 公众号 GitHub ​\thttps://github.com/ROOKIE-AI\n","permalink":"https://Rookie-AI.github.io/about/","summary":"\u003ch1 id=\"关于我\"\u003e关于我\u003c/h1\u003e\n\u003ch3 id=\"公众号\"\u003e公众号\u003c/h3\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/img/wechat_small.jpg\" alt=\"Rookie-AI\"  /\u003e\n\u003c/p\u003e\n\u003ch3 id=\"github\"\u003eGitHub\u003c/h3\u003e\n\u003cp\u003e​\t\t\thttps://github.com/ROOKIE-AI\u003c/p\u003e","title":""},{"content":"kaggle 科学计算竞赛 ","permalink":"https://Rookie-AI.github.io/works/kaggle/","summary":"\u003ch1 id=\"kaggle-科学计算竞赛\"\u003ekaggle 科学计算竞赛\u003c/h1\u003e","title":"Kaggle 竞赛"}]