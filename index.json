[{"content":"Prophet 简介 Prophet 是由 Facebook（现为 Meta）开发的开源时间序列预测工具，旨在为具有趋势和季节性成分的时间序列数据提供高准确性、易解释的预测模型。它基于可加性模型，将时间序列分解为趋势、季节性、节假日效应和残差，为用户提供灵活且强大的预测能力。\n主要特点 易于使用\n快速上手：少量代码即可完成建模和预测。 友好的 API：简单直观的接口，适合数据科学家和业务分析师。 处理复杂的时间序列\n趋势分解：自动检测并建模数据的增长或减少趋势。 季节性调整：支持每日、每周、每年的季节性因素。 节假日效应：纳入节假日和特殊事件的影响。 鲁棒性强\n应对异常值：对缺失值和异常值有良好的容错性。 缺失数据处理：无需对缺失数据进行复杂的插值。 可解释性\n组件分解：单独查看趋势、季节性和节假日效应的影响。 透明的模型参数：便于理解和调整模型。 灵活性\n自定义季节性：允许添加自定义的季节性周期。 支持先验知识：可通过参数调整引入领域知识。 基本原理 Prophet 使用可加性模型，将时间序列表示为多个组件的和：\n$$ y(t) = g(t) + s(t) + h(t) + \\varepsilon_t $$\n其中：\ng(t) ：趋势函数，表示非周期性变化。 s(t) ：季节性函数，表示周期性变化（如年度、每周、每日）。 h(t) ：节假日效应，捕捉特定日期的影响。 ɛ_t ： 误差项，表示未解释的部分。 安装方法 Python 版本安装\npip install prophet 注意：早期版本的包名为 fbprophet，从 v1.0 版本开始更名为 prophet。\nR 版本安装\ninstall.packages(\u0026#39;prophet\u0026#39;) 基本使用步骤 导入库\nfrom prophet import Prophet import pandas as pd 准备数据\n数据需要是一个包含两列的 DataFrame：\nds：日期列，格式为 %Y-%m-%d 或日期时间格式。 y：数值列，表示对应日期的观察值。 df = pd.read_csv(\u0026#39;your_time_series.csv\u0026#39;) df[\u0026#39;ds\u0026#39;] = pd.to_datetime(df[\u0026#39;date_column\u0026#39;]) df[\u0026#39;y\u0026#39;] = df[\u0026#39;value_column\u0026#39;] 创建并拟合模型\nmodel = Prophet() model.fit(df) 进行预测\n创建未来日期的 DataFrame\nfuture = model.make_future_dataframe(periods=365) # periods 参数指定预测的天数 预测未来\nforecast = model.predict(future) 可视化结果\n绘制预测图\nmodel.plot(forecast) 绘制组件图\nmodel.plot_components(forecast) 高级功能 添加自定义季节性\n如果数据中存在特定的季节性，可以自定义添加，例如每周季节性：\nmodel = Prophet(weekly_seasonality=False) model.add_seasonality(name=\u0026#39;weekly\u0026#39;, period=7, fourier_order=3) 纳入节假日效应\nfrom prophet.translate import hdays holidays = hdays(\u0026#39;CN\u0026#39;) # 获取中国的法定节假日 model = Prophet(holidays=holidays) 调整模型参数\n变化点灵活性：控制趋势变化点的灵活性\nmodel = Prophet(changepoint_prior_scale=0.05) 季节性模式：使用乘法季节性\nmodel = Prophet(seasonality_mode=\u0026#39;multiplicative\u0026#39;) 处理异常值\n对异常点进行标记并设置权重：\ndf[\u0026#39;cap\u0026#39;] = 某个上限值 df[\u0026#39;floor\u0026#39;] = 某个下限值 model = Prophet(growth=\u0026#39;logistic\u0026#39;) 模型评估与优化 交叉验证\n使用交叉验证评估模型性能：\nfrom prophet.diagnostics import cross_validation df_cv = cross_validation(model, initial=\u0026#39;730 days\u0026#39;, period=\u0026#39;180 days\u0026#39;, horizon=\u0026#39;365 days\u0026#39;) 性能指标\n计算预测性能指标：\nfrom prophet.diagnostics import performance_metrics df_p = performance_metrics(df_cv) 优势与局限性 优势\n简洁易用：适合没有时间序列背景的用户。 高度自动化：默认参数通常能给出不错的结果。 可扩展性：便于添加自定义组件。 局限性\n对突发性变化敏感：可能无法很好地预测突然的趋势变化。 有限的模型类型：主要基于可加性模型，可能不适用于非加性的复杂模式。 应用场景 业务指标预测：如销售额、用户增长量等。 资源规划：服务器负载、流量监控等。 金融时间序列：股票价格、交易量预测等。 总结 Prophet 是一款强大且易于使用的时间序列预测工具，特别适合处理具有明显趋势和季节性的业务数据。通过灵活的模型配置和友好的接口，用户可以快速构建并部署预测模型，提高业务决策的科学性和准确性。\n","permalink":"https://Rookie-AI.github.io/time-series/%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E5%88%86%E6%9E%90prophet/","summary":"\u003ch3 id=\"prophet-简介\"\u003eProphet 简介\u003c/h3\u003e\n\u003cp\u003eProphet 是由 Facebook（现为 Meta）开发的开源时间序列预测工具，旨在为具有趋势和季节性成分的时间序列数据提供高准确性、易解释的预测模型。它基于可加性模型，将时间序列分解为趋势、季节性、节假日效应和残差，为用户提供灵活且强大的预测能力。\u003c/p\u003e\n\u003chr\u003e\n\u003ch3 id=\"主要特点\"\u003e主要特点\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e易于使用\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e快速上手\u003c/strong\u003e：少量代码即可完成建模和预测。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e友好的 API\u003c/strong\u003e：简单直观的接口，适合数据科学家和业务分析师。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e处理复杂的时间序列\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e趋势分解\u003c/strong\u003e：自动检测并建模数据的增长或减少趋势。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e季节性调整\u003c/strong\u003e：支持每日、每周、每年的季节性因素。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e节假日效应\u003c/strong\u003e：纳入节假日和特殊事件的影响。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e鲁棒性强\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e应对异常值\u003c/strong\u003e：对缺失值和异常值有良好的容错性。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e缺失数据处理\u003c/strong\u003e：无需对缺失数据进行复杂的插值。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e可解释性\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e组件分解\u003c/strong\u003e：单独查看趋势、季节性和节假日效应的影响。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e透明的模型参数\u003c/strong\u003e：便于理解和调整模型。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e灵活性\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e自定义季节性\u003c/strong\u003e：允许添加自定义的季节性周期。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e支持先验知识\u003c/strong\u003e：可通过参数调整引入领域知识。\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3 id=\"基本原理\"\u003e基本原理\u003c/h3\u003e\n\u003cp\u003eProphet 使用可加性模型，将时间序列表示为多个组件的和：\u003c/p\u003e\n\u003cp\u003e$$\ny(t) = g(t) + s(t) + h(t) + \\varepsilon_t\n$$\u003c/p\u003e\n\u003cp\u003e其中：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eg(t) ：趋势函数，表示非周期性变化。\u003c/li\u003e\n\u003cli\u003es(t) ：季节性函数，表示周期性变化（如年度、每周、每日）。\u003c/li\u003e\n\u003cli\u003eh(t) ：节假日效应，捕捉特定日期的影响。\u003c/li\u003e\n\u003cli\u003eɛ_t  ： 误差项，表示未解释的部分。\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3 id=\"安装方法\"\u003e安装方法\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003ePython 版本安装\u003c/strong\u003e\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003epip install prophet\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cblockquote\u003e\n\u003cp\u003e注意：早期版本的包名为 \u003ccode\u003efbprophet\u003c/code\u003e，从 v1.0 版本开始更名为 \u003ccode\u003eprophet\u003c/code\u003e。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003cstrong\u003eR 版本安装\u003c/strong\u003e\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003einstall.packages\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;prophet\u0026#39;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003chr\u003e\n\u003ch3 id=\"基本使用步骤\"\u003e基本使用步骤\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e导入库\u003c/strong\u003e\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003efrom\u003c/span\u003e prophet \u003cspan style=\"color:#f92672\"\u003eimport\u003c/span\u003e Prophet\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003eimport\u003c/span\u003e pandas \u003cspan style=\"color:#66d9ef\"\u003eas\u003c/span\u003e pd\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\u003cstrong\u003e准备数据\u003c/strong\u003e\u003c/p\u003e","title":"时间序列分析: Prophet"},{"content":"关于我 公众号 GitHub ","permalink":"https://Rookie-AI.github.io/about/","summary":"\u003ch1 id=\"关于我\"\u003e关于我\u003c/h1\u003e\n\u003ch3 id=\"公众号\"\u003e公众号\u003c/h3\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/img/wechat_small.jpg\" alt=\"Rookie-AI\"  /\u003e\n\u003c/p\u003e\n\u003ch3 id=\"githubhttpsgithubcomrookie-ai\"\u003e\u003ca href=\"https://github.com/ROOKIE-AI\"\u003eGitHub\u003c/a\u003e\u003c/h3\u003e","title":""},{"content":"🌟 机器学习 🌟 深度学习 🌟 时间序列分析 🌟 CS编程 ","permalink":"https://Rookie-AI.github.io/notebook/","summary":"\u003ch2 id=\"-机器学习ml\"\u003e🌟 \u003ca href=\"/ML/\"\u003e机器学习\u003c/a\u003e\u003c/h2\u003e\n\u003ch2 id=\"-深度学习dl\"\u003e🌟 \u003ca href=\"/dl/\"\u003e深度学习\u003c/a\u003e\u003c/h2\u003e\n\u003ch2 id=\"-时间序列分析time-series\"\u003e🌟 \u003ca href=\"/time-series/\"\u003e时间序列分析\u003c/a\u003e\u003c/h2\u003e\n\u003ch2 id=\"-cs编程cs\"\u003e🌟 \u003ca href=\"/cs/\"\u003eCS编程\u003c/a\u003e\u003c/h2\u003e","title":""},{"content":"从零实现线性神经网络二分类器 import numpy as np from collections import defaultdict import matplotlib.pyplot as plt 本文主要旨在从零对算法进行实现，因此对算法原理的阐述将保持简洁。接下来，我们将概述感知机和逻辑斯蒂回归（Logistic Regression）的基本原理，并提供从零实现这两种算法的示例。此外，我们还将通过启发式方法探讨它们在实际应用中的局限性。\n感知机 算法原理 感知机（Perceptron）是一种基础的线性分类模型，最早由弗兰克·罗森布拉特 (Frank Rosenblatt) 在1958年提出。其主要原理如下：\n1. 模型结构 感知机由输入节点、权重、偏置和激活函数组成：\n输入节点：接收输入特征的值。 权重：每个输入特征都有一个对应的权重，用于衡量特征的重要性。 偏置：一个常数项，使模型能够更灵活地拟合数据。 激活函数：通常是阶跃函数，将加权和转换为输出（0或1）。 2. 工作流程 加权求和：计算输入特征与对应权重的加权和：\n$$ z = \\sum_{i=1}^{n} w_i x_i + b\n$$ 其中，$ w_i $ 是权重，$ x_i $ 是输入特征，$ b $ 是偏置。\n应用激活函数：将加权和 (z) 输入到激活函数中，决定输出类别：\n$$ y = f(z)\n$$ 典型的激活函数为阶跃函数：\n$$ f(z) =\n\\begin{cases}\n1 \u0026amp; \\text{if } z \\geq 0 \\\n0 \u0026amp; \\text{if } z \u0026lt; 0\n\\end{cases}\n$$\n3. 训练过程 感知机使用迭代方法进行训练，主要包括以下步骤：\n初始化权重和偏置：通常设置为小随机值。 更新规则：根据预测错误来调整权重和偏置：\n$$ w_i \\leftarrow w_i + \\eta (y_{\\text{true}} - y_{\\text{pred}}) x_i\n$$ $$ b \\leftarrow b + \\eta (y_{\\text{true}} - y_{\\text{pred}})\n$$ 其中，$\\eta$ 是学习率，$y_{\\text{true}}$ 是真实标签，$y_{\\text{pred}}$ 是模型预测值。 从零实现 class Perceptron: def __init__(self, learning_rate=0.01, n_iter=1000): self.learning_rate = learning_rate # 学习率 self.n_iter = n_iter # 迭代次数 self.weights = None # 权重初始化 self.bias = None # 偏置初始化 def fit(self, X, y): \u0026#34;\u0026#34;\u0026#34; 训练感知机模型 :param X: 输入特征数据，形状为 (n_samples, n_features) :param y: 标签数据，形状为 (n_samples,) \u0026#34;\u0026#34;\u0026#34; n_samples, n_features = X.shape self.weights = np.zeros(n_features) # 初始化权重为零 self.bias = 0 # 初始化偏置为零 # 迭代更新权重 for _ in range(self.n_iter): for idx, x_i in enumerate(X): linear_output = np.dot(x_i, self.weights) + self.bias # 计算加权和 y_predicted = self.activation_function(linear_output) # 应用激活函数 # 更新规则 update = self.learning_rate * (y[idx] - y_predicted) # 计算更新量 self.weights += update * x_i # 更新权重 self.bias += update # 更新偏置 def activation_function(self, x:np.ndarray): \u0026#34;\u0026#34;\u0026#34; 激活函数 :param x: 输入值 :return: 二分类输出（0或1） \u0026#34;\u0026#34;\u0026#34; return (x \u0026gt;= 0).astype(int) # 阶跃函数，返回0或1 def predict(self, X): \u0026#34;\u0026#34;\u0026#34; 对新数据进行预测 :param X: 输入特征数据，形状为 (n_samples, n_features) :return: 预测类别 \u0026#34;\u0026#34;\u0026#34; assert self.weights is not None assert self.bias is not None linear_output = np.dot(X, self.weights) + self.bias # 计算加权和 y_predicted = self.activation_function(linear_output) # 应用激活函数 return y_predicted 启发性认识 下面我们分别构造一组二元分类的特征, 并基于不同类型的标签(与门、与非门、或门和异或门)进行学习\n数据构造 # 创建一个简单的二分类数据集 X = np.array([[0, 0], [0, 1], [1, 0], [1, 1]]) # 输入特征 y_and = np.array([0, 0, 0, 1]) # 与门的输出 y_nand = np.array([1, 1, 1, 0]) # 非与门 y_or = np.array([0, 1, 1, 1]) # 或门 y_xor = np.array([0, 1, 1, 0]) # 异或门 进行训练和预测 res_dict = defaultdict(dict) for y_type, y in zip((\u0026#39;AND\u0026#39;, \u0026#39;NAND\u0026#39;, \u0026#39;OR\u0026#39;, \u0026#39;XOR\u0026#39;), (y_and, y_nand, y_or, y_xor)): perceptron = Perceptron(learning_rate=0.1, n_iter=10) # 初始化感知机 perceptron.fit(X, y) # 训练感知机 predictions = perceptron.predict(X) # 进行预测 save_res = res_dict[y_type] save_res[\u0026#39;weights\u0026#39;] = perceptron.weights save_res[\u0026#39;bias\u0026#39;] = perceptron.bias save_res[\u0026#39;y_hat\u0026#39;] = predictions save_res[\u0026#39;y\u0026#39;] = y save_res[\u0026#39;X\u0026#39;] = X 打印结果 for y_type, results in res_dict.items(): print(y_type) print(f\u0026#34;{\u0026#39;y:\u0026#39;:10}{results[\u0026#39;y\u0026#39;]}\u0026#34;) print(f\u0026#34;{\u0026#39;y_hat:\u0026#39;:10}{results[\u0026#39;y_hat\u0026#39;]}\u0026#34;) print(f\u0026#34;{\u0026#39;weights:\u0026#39;:10}{results[\u0026#39;weights\u0026#39;]}\u0026#34;) print(f\u0026#34;{\u0026#39;bias:\u0026#39;:10}{results[\u0026#39;bias\u0026#39;]: .2f}\u0026#34;) print(\u0026#34;=\u0026#34; * 40) # 分隔线 AND y: [0 0 0 1] y_hat: [0 0 0 1] weights: [0.2 0.1] bias: -0.20 ======================================== NAND y: [1 1 1 0] y_hat: [1 1 1 0] weights: [-0.2 -0.1] bias: 0.20 ======================================== OR y: [0 1 1 1] y_hat: [0 1 1 1] weights: [0.1 0.1] bias: -0.10 ======================================== XOR y: [0 1 1 0] y_hat: [1 1 0 0] weights: [-0.1 0. ] bias: 0.00 ======================================== 可以看出, 除了XOR, 其它的都正确分类了\n可视化演示 x = np.arange(-1, 2, 0.1) fig, axes = plt.subplots(nrows=2, ncols=2, figsize=(10, 10)) axes = axes.flatten() for ax, (k, v) in zip(axes, res_dict.items()): ax: plt.Axes y_line = (- v[\u0026#39;weights\u0026#39;][0] / (v[\u0026#39;weights\u0026#39;][1] + 1e-10)) * x - v[\u0026#39;bias\u0026#39;] / (v[\u0026#39;weights\u0026#39;][1] + 1e-10) # 1e-10 防止分母为0 ax.scatter(*v[\u0026#39;X\u0026#39;][v[\u0026#39;y\u0026#39;] == 1].T, marker=\u0026#39;o\u0026#39;, c=\u0026#39;green\u0026#39;, s=100) ax.scatter(*v[\u0026#39;X\u0026#39;][v[\u0026#39;y\u0026#39;] == 0].T, marker=\u0026#39;x\u0026#39;, c=\u0026#39;red\u0026#39;, s=100) ax.plot(x, y_line) ax.set_title(k) ax.set_xlabel(\u0026#39;x\u0026#39;) ax.set_ylabel(\u0026#39;y\u0026#39;) ax.set_xlim(-1, 2) # 设置 x 轴范围 ax.set_ylim(-1, 2) ax.grid(True) plt.show() ​ ​\n可以看出, 感知机算法可以实现与门, 但是异或门却无法线性可分。\nLogistic回归 算法原理 1. 模型假设 逻辑斯蒂回归的核心思想是通过逻辑函数来预测事件的概率。其主要步骤包括：\n线性组合：与线性回归类似，逻辑斯蒂回归首先计算输入特征的线性组合，即：\n$$ z = W^T x + b\n$$ 其中 $W$ 是权重向量，$x$ 是输入特征，$b$ 是偏置。 2. 激活函数 Sigmoid 函数：逻辑斯蒂回归使用sigmoid函数将线性组合的结果 $z$ 转换为一个介于 0 和 1 之间的概率值，公式为：\n$$ P(y=1|x) = \\frac{1}{1 + e^{-z}}\n$$ 这里 $P(y=1|x)$ 表示在给定特征 $x$ 的情况下，样本属于正类的概率。 3. 决策边界 分类决策：将得到的概率与一个阈值（通常是0.5）进行比较。如果概率大于 0.5，则判断为正类（例如1），否则为负类（例如0）。因此，逻辑斯蒂回归通过定义一个决策边界来进行分类。 4. 损失函数 对数损失：为了训练模型，逻辑斯蒂回归使用对数损失（log loss）作为损失函数，目标是最小化该损失。损失函数定义为：\n$$ L(W, b) = -\\frac{1}{m} \\sum_{i=1}^{m} \\left( y^{(i)} \\log(P(y^{(i)}=1|x^{(i)})) + (1 - y^{(i)}) \\log(1 - P(y^{(i)}=1|x^{(i)})) \\right)\n$$ 其中 $m$ 是样本总数，$y^{(i)}$ 是第 $i$ 个样本的真实标签。 5. 优化 训练过程：使用梯度下降法或其他优化算法（如拟牛顿法）来更新权重 $W$ 和偏置 $b$，直至找到最佳参数以最小化损失函数。 从零实现 class LogisticRegression: def __init__(self, learning_rate=0.1, num_iterations=1000): \u0026#34;\u0026#34;\u0026#34; 初始化逻辑斯蒂回归模型。 参数: learning_rate: 学习率，用于梯度下降法。 num_iterations: 迭代次数。 \u0026#34;\u0026#34;\u0026#34; self.learning_rate = learning_rate self.num_iterations = num_iterations self.weights = None self.bias = None def sigmoid(self, z): return 1 / (1 + np.exp(-z)) def fit(self, X, y): \u0026#34;\u0026#34;\u0026#34; 训练模型，拟合权重和偏置。 参数: X: 输入特征，形状为(n_samples, n_features)的数组。 y: 标签，形状为(n_samples,)的数组。 \u0026#34;\u0026#34;\u0026#34; num_samples, num_features = X.shape self.weights = np.zeros(num_features) # 初始化权重为零 self.bias = 0 # 初始化偏置为零 for _ in range(self.num_iterations): linear_model = np.dot(X, self.weights) + self.bias y_predicted = self.sigmoid(linear_model) # 计算梯度 dw = (1 / num_samples) * (y_predicted - y) @ X db = (1 / num_samples) * np.sum(y_predicted - y) # 更新权重和偏置 self.weights -= self.learning_rate * dw self.bias -= self.learning_rate * db def predict(self, X): assert self.weights is not None assert self.bias is not None linear_model = np.dot(X, self.weights) + self.bias y_predicted = self.sigmoid(linear_model) return [1 if i \u0026gt; 0.5 else 0 for i in y_predicted] 启发性认识 下面我们继续使用之前的数据进行学习\n采用梯度下降进行迭代训练 logistic_res_dict = defaultdict(dict) for y_type, y in zip((\u0026#39;AND\u0026#39;, \u0026#39;NAND\u0026#39;, \u0026#39;OR\u0026#39;, \u0026#39;XOR\u0026#39;), (y_and, y_nand, y_or, y_xor)): model_gd = LogisticRegression(learning_rate=0.1, num_iterations=1000) # 采用梯度下降 model_gd.fit(X, y) # 训练感知机 predictions = model_gd.predict(X) # 进行预测 save_res = logistic_res_dict[y_type] save_res[\u0026#39;weights\u0026#39;] = perceptron.weights save_res[\u0026#39;bias\u0026#39;] = perceptron.bias save_res[\u0026#39;y_hat\u0026#39;] = predictions save_res[\u0026#39;y\u0026#39;] = y save_res[\u0026#39;X\u0026#39;] = X 打印结果并可视化演示 for y_type, results in logistic_res_dict.items(): print(y_type) print(f\u0026#34;{\u0026#39;y:\u0026#39;:10}{results[\u0026#39;y\u0026#39;]}\u0026#34;) print(f\u0026#34;{\u0026#39;y_hat:\u0026#39;:10}{results[\u0026#39;y_hat\u0026#39;]}\u0026#34;) print(f\u0026#34;{\u0026#39;weights:\u0026#39;:10}{results[\u0026#39;weights\u0026#39;]}\u0026#34;) print(f\u0026#34;{\u0026#39;bias:\u0026#39;:10}{results[\u0026#39;bias\u0026#39;]: .2f}\u0026#34;) print(\u0026#34;=\u0026#34; * 40) # 分隔线 x = np.arange(-1, 2, 0.1) fig, axes = plt.subplots(nrows=2, ncols=2, figsize=(10, 10)) axes = axes.flatten() for ax, (k, v) in zip(axes, res_dict.items()): ax: plt.Axes y_line = (- v[\u0026#39;weights\u0026#39;][0] / (v[\u0026#39;weights\u0026#39;][1] + 1e-10)) * x - v[\u0026#39;bias\u0026#39;] / (v[\u0026#39;weights\u0026#39;][1] + 1e-10) # 1e-10 防止分母为0 ax.scatter(*v[\u0026#39;X\u0026#39;][v[\u0026#39;y\u0026#39;] == 1].T, marker=\u0026#39;o\u0026#39;, c=\u0026#39;green\u0026#39;, s=100) ax.scatter(*v[\u0026#39;X\u0026#39;][v[\u0026#39;y\u0026#39;] == 0].T, marker=\u0026#39;x\u0026#39;, c=\u0026#39;red\u0026#39;, s=100) ax.plot(x, y_line) ax.set_title(k) ax.set_xlabel(\u0026#39;x\u0026#39;) ax.set_ylabel(\u0026#39;y\u0026#39;) ax.set_xlim(-1, 2) # 设置 x 轴范围 ax.set_ylim(-1, 2) ax.grid(True) plt.show() AND y: [0 0 0 1] y_hat: [0, 0, 0, 1] weights: [-0.1 0. ] bias: 0.00 ======================================== NAND y: [1 1 1 0] y_hat: [1, 1, 1, 0] weights: [-0.1 0. ] bias: 0.00 ======================================== OR y: [0 1 1 1] y_hat: [0, 1, 1, 1] weights: [-0.1 0. ] bias: 0.00 ======================================== XOR y: [0 1 1 0] y_hat: [0, 0, 0, 0] weights: [-0.1 0. ] bias: 0.00 ======================================== 显然, 同样的结果。\n总结 相信很多朋友发现, 感知机模型和逻辑斯蒂回归这两者在结构上挺像的，都可以看作是单个神经元的模型，但它们使用了不同的激活函数。\n首先，感知机一般使用阶跃函数，这种函数的特点是，当输入大于某个值时，输出就是1；否则就是0。而逻辑斯蒂回归则使用的是sigmoid函数，它把输出压缩到0到1之间，非常适合做概率预测。\n在损失函数方面, 感知机采用的是铰链损失，这种损失关注的是分类错误的样本。而逻辑斯蒂回归使用的是对数损失。这种损失的目标是最大化似然函数，换句话说，就是让模型尽量准确地预测出每个样本的概率。\n在优化方面，感知机有自己的一套学习算法，它通过不断的迭代来更新权重，直到所有训练样本都被正确分类，或者满足了某些迭代条件。而逻辑斯蒂回归通常会采用梯度下降法或者拟牛顿法这样的优化方法，反复调整权重，力求找到最好的参数组合，最小化损失函数。\n感知机模型和逻辑斯蒂回归通常解决的是二分类问题, 那么对于多分类问题呢? 通常我们采用的是逻辑斯蒂回归的扩展版: SoftMax回归, 它采用了单层的多个神经元, 并加入了softmax层将每个神经元最后的输出转化为对应每个分类的概率。下期将为大家来从零实现这个softmax回归。\n","permalink":"https://Rookie-AI.github.io/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/01.%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%E7%BA%BF%E6%80%A7%E7%A5%9E%E7%BB%8F%E5%85%83%E4%BA%8C%E5%88%86%E7%B1%BB%E5%99%A8/01.%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%E7%BA%BF%E6%80%A7%E7%A5%9E%E7%BB%8F%E5%85%83%E4%BA%8C%E5%88%86%E7%B1%BB%E5%99%A8/","summary":"\u003ch1 id=\"从零实现线性神经网络二分类器\"\u003e从零实现线性神经网络二分类器\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003eimport\u003c/span\u003e numpy \u003cspan style=\"color:#66d9ef\"\u003eas\u003c/span\u003e np  \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003efrom\u003c/span\u003e collections \u003cspan style=\"color:#f92672\"\u003eimport\u003c/span\u003e defaultdict\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003eimport\u003c/span\u003e matplotlib.pyplot \u003cspan style=\"color:#66d9ef\"\u003eas\u003c/span\u003e plt\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e  本文主要旨在从零对算法进行实现，因此对算法原理的阐述将保持简洁。接下来，我们将概述感知机和逻辑斯蒂回归（Logistic Regression）的基本原理，并提供从零实现这两种算法的示例。此外，我们还将通过启发式方法探讨它们在实际应用中的局限性。\u003c/p\u003e\n\u003ch2 id=\"感知机\"\u003e感知机\u003c/h2\u003e\n\u003ch3 id=\"算法原理\"\u003e算法原理\u003c/h3\u003e\n\u003cp\u003e感知机（Perceptron）是一种基础的线性分类模型，最早由弗兰克·罗森布拉特 (Frank Rosenblatt) 在1958年提出。其主要原理如下：\u003c/p\u003e\n\u003ch4 id=\"1-模型结构\"\u003e1. 模型结构\u003c/h4\u003e\n\u003cp\u003e感知机由输入节点、权重、偏置和激活函数组成：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e输入节点\u003c/strong\u003e：接收输入特征的值。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e权重\u003c/strong\u003e：每个输入特征都有一个对应的权重，用于衡量特征的重要性。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e偏置\u003c/strong\u003e：一个常数项，使模型能够更灵活地拟合数据。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e激活函数\u003c/strong\u003e：通常是阶跃函数，将加权和转换为输出（0或1）。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"2-工作流程\"\u003e2. 工作流程\u003c/h4\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e加权求和\u003c/strong\u003e：计算输入特征与对应权重的加权和：\u003cbr\u003e\n$$\nz = \\sum_{i=1}^{n} w_i x_i + b\u003cbr\u003e\n$$\n其中，$ w_i $ 是权重，$ x_i $ 是输入特征，$ b $ 是偏置。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e应用激活函数\u003c/strong\u003e：将加权和 (z) 输入到激活函数中，决定输出类别：\u003cbr\u003e\n$$\ny = f(z)\u003cbr\u003e\n$$\n典型的激活函数为阶跃函数：\u003cbr\u003e\n$$\nf(z) =\u003cbr\u003e\n\\begin{cases}\u003cbr\u003e\n1 \u0026amp; \\text{if } z \\geq 0 \\\u003cbr\u003e\n0 \u0026amp; \\text{if } z \u0026lt; 0\u003cbr\u003e\n\\end{cases}\u003cbr\u003e\n$$\u003c/p\u003e","title":""},{"content":"Python学习笔记 介绍 这里收录了我在学习Python过程中整理的笔记、代码示例和重要概念。主要基于《流畅的Python》和《Python 3 面向对象编程》等优秀教材，涵盖从基础语法到高级特性的多个方面。\n学习资源 参考书籍 《流畅的Python》(Fluent Python) - Luciano Ramalho 《Python 3 面向对象编程》(Python 3 Object-Oriented Programming) 主要内容 《流畅的Python》笔记 Python数据模型 - 特殊方法、魔术方法、对象表示 序列构成的数组 - 列表推导式、生成器表达式、元组解包 字典与集合 - 映射类型、散列表、可散列类型 文本和字节序列 - 字符编码、Unicode、二进制序列 一等函数 - 函数对象、高阶函数、匿名函数 函数装饰器和闭包 - 闭包原理、装饰器模式 对象引用、可变性和垃圾回收 - 变量引用、不可变性、弱引用 符合Python风格的对象 - 对象表示形式、格式化、特性属性 序列的修改、散切和切片 - 协议、可切片序列、动态属性 接口-从协议到抽象基类 - 鸭子类型、抽象基类、虚拟子类 《Python 3 面向对象编程》笔记 异常捕获 - 异常处理、自定义异常 何时使用面向对象编程 Python数据结构 - 元组、命名元组、字典、列表、集合 特点 包含丰富的代码示例和输出结果 每章总结有关键概念图解 Jupyter Notebook格式，便于互动学习和执行代码 重点突出Python的特性和最佳实践 代码仓库 所有笔记和代码示例都可以在我的GitHub仓库中找到： Python学习笔记仓库\n","permalink":"https://Rookie-AI.github.io/cs/python/","summary":"\u003ch1 id=\"python学习笔记\"\u003ePython学习笔记\u003c/h1\u003e\n\u003ch2 id=\"介绍\"\u003e介绍\u003c/h2\u003e\n\u003cp\u003e这里收录了我在学习Python过程中整理的笔记、代码示例和重要概念。主要基于《流畅的Python》和《Python 3 面向对象编程》等优秀教材，涵盖从基础语法到高级特性的多个方面。\u003c/p\u003e\n\u003ch2 id=\"学习资源\"\u003e学习资源\u003c/h2\u003e\n\u003ch3 id=\"参考书籍\"\u003e参考书籍\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e《流畅的Python》(Fluent Python) - Luciano Ramalho\u003c/li\u003e\n\u003cli\u003e《Python 3 面向对象编程》(Python 3 Object-Oriented Programming)\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"主要内容\"\u003e主要内容\u003c/h2\u003e\n\u003ch3 id=\"流畅的python笔记\"\u003e《流畅的Python》笔记\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003ePython数据模型\u003c/strong\u003e - 特殊方法、魔术方法、对象表示\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e序列构成的数组\u003c/strong\u003e - 列表推导式、生成器表达式、元组解包\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e字典与集合\u003c/strong\u003e - 映射类型、散列表、可散列类型\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e文本和字节序列\u003c/strong\u003e - 字符编码、Unicode、二进制序列\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e一等函数\u003c/strong\u003e - 函数对象、高阶函数、匿名函数\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e函数装饰器和闭包\u003c/strong\u003e - 闭包原理、装饰器模式\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e对象引用、可变性和垃圾回收\u003c/strong\u003e - 变量引用、不可变性、弱引用\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e符合Python风格的对象\u003c/strong\u003e - 对象表示形式、格式化、特性属性\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e序列的修改、散切和切片\u003c/strong\u003e - 协议、可切片序列、动态属性\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e接口-从协议到抽象基类\u003c/strong\u003e - 鸭子类型、抽象基类、虚拟子类\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"python-3-面向对象编程笔记\"\u003e《Python 3 面向对象编程》笔记\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e异常捕获\u003c/strong\u003e - 异常处理、自定义异常\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e何时使用面向对象编程\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ePython数据结构\u003c/strong\u003e - 元组、命名元组、字典、列表、集合\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"特点\"\u003e特点\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e包含丰富的代码示例和输出结果\u003c/li\u003e\n\u003cli\u003e每章总结有关键概念图解\u003c/li\u003e\n\u003cli\u003eJupyter Notebook格式，便于互动学习和执行代码\u003c/li\u003e\n\u003cli\u003e重点突出Python的特性和最佳实践\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"代码仓库\"\u003e代码仓库\u003c/h2\u003e\n\u003cp\u003e所有笔记和代码示例都可以在我的GitHub仓库中找到：\n\u003ca href=\"https://github.com/Rookie-CS/Python\"\u003ePython学习笔记仓库\u003c/a\u003e\u003c/p\u003e","title":"Python学习笔记"},{"content":"SQL学习笔记 介绍 本笔记集合记录了SQL学习过程中的重要知识点和实践经验，主要基于MySQL数据库。使用Jupyter Notebook格式记录，内容涵盖了从基础语法到高级查询的完整SQL知识体系。\n环境配置 笔记使用的环境：\nPython 3.11.9 Jupyter Notebook MySQL 数据库 mysql-connector-python ipython-sql 扩展 主要内容 1. MySQL连接 Jupyter魔法方法连接MySQL 使用Python库连接MySQL 2. SQL通用语法及分类 DDL (数据定义语言) DML (数据操作语言) DQL (数据查询语言) DCL (数据控制语言) 3. DDL - 数据定义语言 数据库操作：创建、查询、修改、删除 表操作：创建表、删除表、修改表结构 字段操作：添加、修改、删除字段 4. DML - 数据操作语言 添加数据 修改数据 删除数据 5. DQL - 数据查询语言 基本查询 条件查询 (WHERE) 聚合函数 (count、max、min、avg、sum) 分组查询 (GROUP BY) 排序查询 (ORDER BY) 分页查询 (LIMIT) 执行顺序 6. DCL - 数据控制语言 用户管理：创建、修改、删除用户 权限控制：授予权限、撤销权限 查询权限 7. 函数 字符串函数 数字函数 日期函数 流程控制函数 窗口函数 8. 约束 主键约束 非空约束 唯一约束 默认约束 检查约束 外键约束 9. 多表查询 多表关系：一对多、多对多、一对一 连接查询： 内连接 外连接（左连接、右连接） 自连接 子查询： 标量子查询 列子查询 行子查询 表子查询 10. 事务 事务的基本概念 事务的ACID特性 事务控制 特点 系统化的知识结构 详细的代码示例 Jupyter格式，可交互执行 包含实际案例和解释 适合入门到进阶的SQL学习 示例数据 笔记中使用了MySQL自带的world数据库进行演示，这个数据库包含了国家、城市和语言等相关数据。\n代码仓库 所有笔记和代码示例都可以在我的GitHub仓库中找到： SQL学习笔记仓库\n","permalink":"https://Rookie-AI.github.io/cs/sql/","summary":"\u003ch1 id=\"sql学习笔记\"\u003eSQL学习笔记\u003c/h1\u003e\n\u003ch2 id=\"介绍\"\u003e介绍\u003c/h2\u003e\n\u003cp\u003e本笔记集合记录了SQL学习过程中的重要知识点和实践经验，主要基于MySQL数据库。使用Jupyter Notebook格式记录，内容涵盖了从基础语法到高级查询的完整SQL知识体系。\u003c/p\u003e\n\u003ch2 id=\"环境配置\"\u003e环境配置\u003c/h2\u003e\n\u003cp\u003e笔记使用的环境：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ePython 3.11.9\u003c/li\u003e\n\u003cli\u003eJupyter Notebook\u003c/li\u003e\n\u003cli\u003eMySQL 数据库\u003c/li\u003e\n\u003cli\u003emysql-connector-python\u003c/li\u003e\n\u003cli\u003eipython-sql 扩展\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"主要内容\"\u003e主要内容\u003c/h2\u003e\n\u003ch3 id=\"1-mysql连接\"\u003e1. MySQL连接\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eJupyter魔法方法连接MySQL\u003c/li\u003e\n\u003cli\u003e使用Python库连接MySQL\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"2-sql通用语法及分类\"\u003e2. SQL通用语法及分类\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eDDL\u003c/strong\u003e (数据定义语言)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eDML\u003c/strong\u003e (数据操作语言)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eDQL\u003c/strong\u003e (数据查询语言)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eDCL\u003c/strong\u003e (数据控制语言)\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"3-ddl---数据定义语言\"\u003e3. DDL - 数据定义语言\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e数据库操作：创建、查询、修改、删除\u003c/li\u003e\n\u003cli\u003e表操作：创建表、删除表、修改表结构\u003c/li\u003e\n\u003cli\u003e字段操作：添加、修改、删除字段\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"4-dml---数据操作语言\"\u003e4. DML - 数据操作语言\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e添加数据\u003c/li\u003e\n\u003cli\u003e修改数据\u003c/li\u003e\n\u003cli\u003e删除数据\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"5-dql---数据查询语言\"\u003e5. DQL - 数据查询语言\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e基本查询\u003c/li\u003e\n\u003cli\u003e条件查询 (WHERE)\u003c/li\u003e\n\u003cli\u003e聚合函数 (count、max、min、avg、sum)\u003c/li\u003e\n\u003cli\u003e分组查询 (GROUP BY)\u003c/li\u003e\n\u003cli\u003e排序查询 (ORDER BY)\u003c/li\u003e\n\u003cli\u003e分页查询 (LIMIT)\u003c/li\u003e\n\u003cli\u003e执行顺序\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"6-dcl---数据控制语言\"\u003e6. DCL - 数据控制语言\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e用户管理：创建、修改、删除用户\u003c/li\u003e\n\u003cli\u003e权限控制：授予权限、撤销权限\u003c/li\u003e\n\u003cli\u003e查询权限\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"7-函数\"\u003e7. 函数\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e字符串函数\u003c/li\u003e\n\u003cli\u003e数字函数\u003c/li\u003e\n\u003cli\u003e日期函数\u003c/li\u003e\n\u003cli\u003e流程控制函数\u003c/li\u003e\n\u003cli\u003e窗口函数\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"8-约束\"\u003e8. 约束\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e主键约束\u003c/li\u003e\n\u003cli\u003e非空约束\u003c/li\u003e\n\u003cli\u003e唯一约束\u003c/li\u003e\n\u003cli\u003e默认约束\u003c/li\u003e\n\u003cli\u003e检查约束\u003c/li\u003e\n\u003cli\u003e外键约束\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"9-多表查询\"\u003e9. 多表查询\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e多表关系：一对多、多对多、一对一\u003c/li\u003e\n\u003cli\u003e连接查询：\n\u003cul\u003e\n\u003cli\u003e内连接\u003c/li\u003e\n\u003cli\u003e外连接（左连接、右连接）\u003c/li\u003e\n\u003cli\u003e自连接\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e子查询：\n\u003cul\u003e\n\u003cli\u003e标量子查询\u003c/li\u003e\n\u003cli\u003e列子查询\u003c/li\u003e\n\u003cli\u003e行子查询\u003c/li\u003e\n\u003cli\u003e表子查询\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"10-事务\"\u003e10. 事务\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e事务的基本概念\u003c/li\u003e\n\u003cli\u003e事务的ACID特性\u003c/li\u003e\n\u003cli\u003e事务控制\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"特点\"\u003e特点\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e系统化的知识结构\u003c/li\u003e\n\u003cli\u003e详细的代码示例\u003c/li\u003e\n\u003cli\u003eJupyter格式，可交互执行\u003c/li\u003e\n\u003cli\u003e包含实际案例和解释\u003c/li\u003e\n\u003cli\u003e适合入门到进阶的SQL学习\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"示例数据\"\u003e示例数据\u003c/h2\u003e\n\u003cp\u003e笔记中使用了MySQL自带的\u003ccode\u003eworld\u003c/code\u003e数据库进行演示，这个数据库包含了国家、城市和语言等相关数据。\u003c/p\u003e","title":"SQL学习笔记"},{"content":"大模型应用 供电服务智能问答系统 该系统是一个基于大语言模型的智能客服解决方案，专为电力行业设计。通过处理客户音频通话记录，系统提供智能分析和专业解答。主要功能包括：\n语音识别：支持多种音频格式转文字 智能分析：自动提取通话关键信息（受理时间、联系人、地址、内容、跟进事项） 专业问答：基于供电营业规则知识库提供解答 结构化输出：清晰展示分析结果和解决方案 技术上，系统集成了Streamlit、LangChain、FAISS向量数据库和Whisper语音识别，通过OpenAI API提供强大的语言理解能力。\n在线演示 | 项目代码\n会议准备AI助手 该系统是一个智能会议准备工具，通过多个AI助手协同工作，为用户生成全面的会议准备材料。主要特点包括：\n多AI助手协同系统：\n背景分析专家：深入研究公司信息 行业专家：分析市场趋势 策略专家：制定会议策略 沟通专家：整合信息输出 多文档处理能力：支持Word、PDF、PPT、Excel等多种文档格式\n智能分析输出：\n会议背景分析 行业趋势洞察 定制化会议策略 详细执行简报 技术上，系统基于Streamlit开发，集成了OpenAI的GPT模型和维基百科搜索功能，提供实时分析进度展示和详细日志记录。\n在线演示 | 项目代码\n","permalink":"https://Rookie-AI.github.io/works/genai/","summary":"\u003ch2 id=\"大模型应用\"\u003e大模型应用\u003c/h2\u003e\n\u003ch3 id=\"供电服务智能问答系统\"\u003e供电服务智能问答系统\u003c/h3\u003e\n\u003cp\u003e该系统是一个基于大语言模型的智能客服解决方案，专为电力行业设计。通过处理客户音频通话记录，系统提供智能分析和专业解答。主要功能包括：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e语音识别\u003c/strong\u003e：支持多种音频格式转文字\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e智能分析\u003c/strong\u003e：自动提取通话关键信息（受理时间、联系人、地址、内容、跟进事项）\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e专业问答\u003c/strong\u003e：基于供电营业规则知识库提供解答\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e结构化输出\u003c/strong\u003e：清晰展示分析结果和解决方案\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e技术上，系统集成了Streamlit、LangChain、FAISS向量数据库和Whisper语音识别，通过OpenAI API提供强大的语言理解能力。\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://master-qtqkunyeoqrl22xzuyxayp.streamlit.app/\"\u003e在线演示\u003c/a\u003e | \u003ca href=\"https://github.com/ROOKIE-AI/Intelligent-Analysis-System-for-Power-Supply-Customer-Service-Conversations\"\u003e项目代码\u003c/a\u003e\u003c/p\u003e\n\u003ch3 id=\"会议准备ai助手\"\u003e会议准备AI助手\u003c/h3\u003e\n\u003cp\u003e该系统是一个智能会议准备工具，通过多个AI助手协同工作，为用户生成全面的会议准备材料。主要特点包括：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e多AI助手协同系统\u003c/strong\u003e：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e背景分析专家：深入研究公司信息\u003c/li\u003e\n\u003cli\u003e行业专家：分析市场趋势\u003c/li\u003e\n\u003cli\u003e策略专家：制定会议策略\u003c/li\u003e\n\u003cli\u003e沟通专家：整合信息输出\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e多文档处理能力\u003c/strong\u003e：支持Word、PDF、PPT、Excel等多种文档格式\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e智能分析输出\u003c/strong\u003e：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e会议背景分析\u003c/li\u003e\n\u003cli\u003e行业趋势洞察\u003c/li\u003e\n\u003cli\u003e定制化会议策略\u003c/li\u003e\n\u003cli\u003e详细执行简报\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e技术上，系统基于Streamlit开发，集成了OpenAI的GPT模型和维基百科搜索功能，提供实时分析进度展示和详细日志记录。\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://9yskzputwjappacugobfxwo.streamlit.app/\"\u003e在线演示\u003c/a\u003e | \u003ca href=\"https://github.com/ROOKIE-AI/ai_meeting_agent\"\u003e项目代码\u003c/a\u003e\u003c/p\u003e","title":"大模型应用"},{"content":"时间序列预测项目 WindCast: 风力发电预测系统 该项目基于龙源电力集团提供的SDWPF（Sustainable Development Wind Power Forecasting）数据集，构建了一个风力发电预测系统。系统利用机器学习方法，通过分析风速、温度等多个特征，对风力涡轮机的发电量进行精确预测。\n主要功能 数据预处理与清洗\n异常值检测与处理 缺失值填补 数据标准化 特征工程\n角度特征转换（正弦/余弦编码） 时间特征编码 温度数据修正 冗余特征删除 预测模型\n线性回归模型（单变量/多变量） 神经网络模型(MLP、Conv-LSTM) 特征重要性分析 关键特征 系统分析的主要特征包括：\n风速(Wspd) 风向(Wdir) 环境温度(Etmp) 内部温度(Itmp) 机舱方向(Ndir) 叶片角度(Pab) 相对功率(Prtv) 有功功率(Patv)：预测目标 技术栈 pandas、numpy：数据处理 matplotlib、seaborn：数据可视化 scikit-learn：机器学习模型 PyTorch：深度学习模型 SHAP：模型解释性分析 项目采用平均绝对误差(MAE)作为评估指标，提供预测值与实际值的可视化对比及特征重要性分析，使结果更加直观可解释。\n项目代码\n","permalink":"https://Rookie-AI.github.io/works/timeseries/","summary":"\u003ch2 id=\"时间序列预测项目\"\u003e时间序列预测项目\u003c/h2\u003e\n\u003ch3 id=\"windcast-风力发电预测系统\"\u003eWindCast: 风力发电预测系统\u003c/h3\u003e\n\u003cp\u003e该项目基于龙源电力集团提供的SDWPF（Sustainable Development Wind Power Forecasting）数据集，构建了一个风力发电预测系统。系统利用机器学习方法，通过分析风速、温度等多个特征，对风力涡轮机的发电量进行精确预测。\u003c/p\u003e\n\u003ch4 id=\"主要功能\"\u003e主要功能\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e数据预处理与清洗\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e异常值检测与处理\u003c/li\u003e\n\u003cli\u003e缺失值填补\u003c/li\u003e\n\u003cli\u003e数据标准化\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e特征工程\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e角度特征转换（正弦/余弦编码）\u003c/li\u003e\n\u003cli\u003e时间特征编码\u003c/li\u003e\n\u003cli\u003e温度数据修正\u003c/li\u003e\n\u003cli\u003e冗余特征删除\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e预测模型\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e线性回归模型（单变量/多变量）\u003c/li\u003e\n\u003cli\u003e神经网络模型(MLP、Conv-LSTM)\u003c/li\u003e\n\u003cli\u003e特征重要性分析\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"关键特征\"\u003e关键特征\u003c/h4\u003e\n\u003cp\u003e系统分析的主要特征包括：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e风速(Wspd)\u003c/li\u003e\n\u003cli\u003e风向(Wdir)\u003c/li\u003e\n\u003cli\u003e环境温度(Etmp)\u003c/li\u003e\n\u003cli\u003e内部温度(Itmp)\u003c/li\u003e\n\u003cli\u003e机舱方向(Ndir)\u003c/li\u003e\n\u003cli\u003e叶片角度(Pab)\u003c/li\u003e\n\u003cli\u003e相对功率(Prtv)\u003c/li\u003e\n\u003cli\u003e有功功率(Patv)：预测目标\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"技术栈\"\u003e技术栈\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003epandas、numpy：数据处理\u003c/li\u003e\n\u003cli\u003ematplotlib、seaborn：数据可视化\u003c/li\u003e\n\u003cli\u003escikit-learn：机器学习模型\u003c/li\u003e\n\u003cli\u003ePyTorch：深度学习模型\u003c/li\u003e\n\u003cli\u003eSHAP：模型解释性分析\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e项目采用平均绝对误差(MAE)作为评估指标，提供预测值与实际值的可视化对比及特征重要性分析，使结果更加直观可解释。\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/ROOKIE-AI/WindCast\"\u003e项目代码\u003c/a\u003e\u003c/p\u003e","title":"时间序列预测项目"},{"content":"xyplot - 气象行业的专业绘图框架 xyplot是一个专为气象行业设计的Python绘图封装库，基于Matplotlib构建。它提供了简洁的API和灵活的配置选项，帮助用户高效地创建专业级别的气象数据可视化图表。\n主要特性 简化绘图流程：大幅减少绘图代码量，提高开发效率 配置化设计：支持通过外部配置文件进行个性化定制 组件化架构：便于代码复用和维护 丰富的图表类型：支持等高线填充图、流线图、散点图、折线图等气象常用图表 灵活的布局系统：支持多种子图布局方式（subplot、subplot2grid、add_axes） 精细化控制：提供对坐标轴、色阶、图例等元素的详细设置 设计理念 xyplot采用面向对象的设计思路，结合了多种设计模式（建造者模式、适配器模式、模板方法模式等），使代码结构清晰、易于扩展。其目标是：\n简化绘图方法，降低绘图代码量 便于绘图代码的封装分类，提高其复用性和维护性 支持通过外部配置文件对可视化产品进行个性化定制 为未来的绘图GUI/Web配置化打下基础 使用示例 import numpy as np from xyplot import XyPlot # 准备数据 x = np.linspace(-np.pi, np.pi, 100) y = np.sin(x) # 配置字典 set_fig_dict = dict(height=10, width=10) axes_dict = dict( plot=dict(args=(x, y), label=\u0026#39;y=sin(x)\u0026#39;, c=\u0026#39;k\u0026#39;), title=r\u0026#39;y=sin(x)\u0026#39; ) # 创建并显示图表 cfg = dict(set_fig=set_fig_dict, axes=axes_dict) xyplt = XyPlot(**cfg) xyplt.show() 主要组件 XyPlot：顶层绘图对象，用于控制整体绘图流程 AxesBuilder：用于构建和配置Matplotlib Axes对象 ContourfDirector：等高线填充图绘制对象 ColorMapBuilder：色阶颜色映射构建设置类 SetFigure：画布设置类 SetAxes：子区域绘图对象设置类 项目链接 更多详细信息和代码示例，请访问项目GitHub仓库：xyplot\n","permalink":"https://Rookie-AI.github.io/works/matplotlib/","summary":"\u003ch1 id=\"xyplot---气象行业的专业绘图框架\"\u003exyplot - 气象行业的专业绘图框架\u003c/h1\u003e\n\u003cp\u003exyplot是一个专为气象行业设计的Python绘图封装库，基于Matplotlib构建。它提供了简洁的API和灵活的配置选项，帮助用户高效地创建专业级别的气象数据可视化图表。\u003c/p\u003e\n\u003ch2 id=\"主要特性\"\u003e主要特性\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e简化绘图流程\u003c/strong\u003e：大幅减少绘图代码量，提高开发效率\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e配置化设计\u003c/strong\u003e：支持通过外部配置文件进行个性化定制\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e组件化架构\u003c/strong\u003e：便于代码复用和维护\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e丰富的图表类型\u003c/strong\u003e：支持等高线填充图、流线图、散点图、折线图等气象常用图表\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e灵活的布局系统\u003c/strong\u003e：支持多种子图布局方式（subplot、subplot2grid、add_axes）\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e精细化控制\u003c/strong\u003e：提供对坐标轴、色阶、图例等元素的详细设置\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"设计理念\"\u003e设计理念\u003c/h2\u003e\n\u003cp\u003exyplot采用面向对象的设计思路，结合了多种设计模式（建造者模式、适配器模式、模板方法模式等），使代码结构清晰、易于扩展。其目标是：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e简化绘图方法，降低绘图代码量\u003c/li\u003e\n\u003cli\u003e便于绘图代码的封装分类，提高其复用性和维护性\u003c/li\u003e\n\u003cli\u003e支持通过外部配置文件对可视化产品进行个性化定制\u003c/li\u003e\n\u003cli\u003e为未来的绘图GUI/Web配置化打下基础\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"使用示例\"\u003e使用示例\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003eimport\u003c/span\u003e numpy \u003cspan style=\"color:#66d9ef\"\u003eas\u003c/span\u003e np\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003efrom\u003c/span\u003e xyplot \u003cspan style=\"color:#f92672\"\u003eimport\u003c/span\u003e XyPlot\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# 准备数据\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ex \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e np\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003elinspace(\u003cspan style=\"color:#f92672\"\u003e-\u003c/span\u003enp\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003epi, np\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003epi, \u003cspan style=\"color:#ae81ff\"\u003e100\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ey \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e np\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003esin(x)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# 配置字典\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eset_fig_dict \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e dict(height\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e10\u003c/span\u003e, width\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e10\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eaxes_dict \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e dict(\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    plot\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003edict(args\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e(x, y), label\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;y=sin(x)\u0026#39;\u003c/span\u003e, c\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;k\u0026#39;\u003c/span\u003e),\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    title\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003er\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;y=sin(x)\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# 创建并显示图表\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ecfg \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e dict(set_fig\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eset_fig_dict, axes\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eaxes_dict)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003exyplt \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e XyPlot(\u003cspan style=\"color:#f92672\"\u003e**\u003c/span\u003ecfg)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003exyplt\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003eshow()\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"主要组件\"\u003e主要组件\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eXyPlot\u003c/strong\u003e：顶层绘图对象，用于控制整体绘图流程\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eAxesBuilder\u003c/strong\u003e：用于构建和配置Matplotlib Axes对象\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eContourfDirector\u003c/strong\u003e：等高线填充图绘制对象\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eColorMapBuilder\u003c/strong\u003e：色阶颜色映射构建设置类\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eSetFigure\u003c/strong\u003e：画布设置类\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eSetAxes\u003c/strong\u003e：子区域绘图对象设置类\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"项目链接\"\u003e项目链接\u003c/h2\u003e\n\u003cp\u003e更多详细信息和代码示例，请访问项目GitHub仓库：\u003ca href=\"https://github.com/Rookiehhh/xyplot.git\"\u003exyplot\u003c/a\u003e\u003c/p\u003e","title":"气象绘图框架"},{"content":"在线资源 动手学习深度学习-李沐 谷歌机器学习教育 Machine Learning Simplified书籍的补充 注意力机制和记忆网络初学者指南 RNN中的记忆可视化 芦苇的机器学习笔记 中文数据科学笔记 吴恩达-深度学习笔记(手机阅读) 吴恩达老师的深度学习课程笔记及资源(Github) 动手学深度学习-李沐 个人笔记 ","permalink":"https://Rookie-AI.github.io/dl/","summary":"\u003ch3 id=\"在线资源\"\u003e在线资源\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://zh-v2.d2l.ai/\"\u003e动手学习深度学习-李沐\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://developers.google.com/machine-learning?hl=zh-cn\"\u003e谷歌机器学习教育\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://code.themlsbook.com/index.html\"\u003e\u003cstrong\u003eMachine Learning Simplified\u003c/strong\u003e书籍的\u003cstrong\u003e补充\u003c/strong\u003e\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://wiki.pathmind.com/attention-mechanism-memory-network\"\u003e注意力机制和记忆网络初学者指南\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://distill.pub/2019/memorization-in-rnns/\"\u003eRNN中的记忆可视化\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://luweiagi.github.io/machine-learning-notes/#/\"\u003e芦苇的机器学习笔记\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://nbviewer.org/github/ROOKIE-AI/Data-Science-Notes\"\u003e中文数据科学笔记\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"http://www.ai-start.com/dl2017/\"\u003e吴恩达-深度学习笔记(手机阅读)\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/ROOKIE-AI/deeplearning_ai_books\"\u003e吴恩达老师的深度学习课程笔记及资源(Github)\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"动手学深度学习-李沐-个人笔记httpsnbviewerorggithubrookie-aidltreemaind2lme\"\u003e\u003ca href=\"https://nbviewer.org/github/ROOKIE-AI/DL/tree/main/d2l/me\"\u003e动手学深度学习-李沐 个人笔记\u003c/a\u003e\u003c/h3\u003e","title":"深度学习"}]